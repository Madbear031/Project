# Адаптер
### Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
## Проблема
К примеру, несовместимость каких-либо загружаемых данных с подключаемой библиотекой при невозможности изменения исходного кода библиотеки.
## Решение
Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.
Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Это работает так:
1.	Адаптер имеет интерфейс, который совместим с одним из объектов.
2.	Поэтому этот объект может свободно вызывать методы адаптера.
3.	Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.
Иногда возможно создать даже двухсторонний адаптер, который работал бы в обе стороны.

## Структура
### Адаптер объектов
![.](https://github.com/leha2976/Project/blob/master/%D0%9F%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2.jpg)

Эта реализация использует агрегацию: объект адаптера «оборачивает», то есть содержит ссылку на служебный объект. Такой подход работает во всех языках программирования.
 
1.	Клиент — это класс, который содержит существующую бизнес-логику программы.
2.	Клиентский интерфейс описывает протокол, через который клиент может работать с другими классами.
3.	Сервис – это какой-то полезный класс, обычно сторонний. Клиент не может использовать этот класс напрямую, так как сервис имеет непонятный ему интерфейс.
4.	Адаптер — это класс, который может одновременно работать и с клиентом, и с сервисом. Он реализует клиентский интерфейс и содержит ссылку на объект сервиса. Адаптер получает вызовы от клиента через методы клиентского интерфейса, а затем переводит их в вызовы методов обёрнутого объекта в правильном формате.
5.	Работая с адаптером через интерфейс, клиент не привязывается к конкретному классу адаптера. Благодаря этому, вы можете добавлять в программу новые виды адаптеров, независимо от клиентского кода. Это может пригодиться, если интерфейс сервиса вдруг изменится, например, после выхода новой версии сторонней библиотеки.

### Адаптер классов
Эта реализация базируется на наследовании: адаптер наследует оба интерфейса одновременно. Такой подход возможен только в языках, поддерживающих множественное наследование, например, C++.
![.](https://github.com/leha2976/Project/blob/master/%D0%9F%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2.jpg)

Адаптер классов не нуждается во вложенном объекте, так как он может одновременно наследовать и часть существующего класса, и часть сервиса.
 
## Применимость
### Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.
 Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.
### Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.
 Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность. Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.
Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. 
## Шаги реализации
1.	Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
o	полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
o	один или несколько клиентов — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.
2.	Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
3.	Создайте класс адаптера, реализовав этот интерфейс.
4.	Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5.	Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
6.	Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.
## Преимущества 
•	 Отделяет и скрывает от клиента подробности преобразования различных интерфейсов
## Недостатки
•	 Усложняет код программы из-за введения дополнительных классов.

